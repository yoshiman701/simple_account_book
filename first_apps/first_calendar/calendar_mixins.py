import calendarfrom collections import dequeimport datetimeimport itertoolsfrom .models import Schedule,Money,Categoryimport matplotlib#バックエンドを指定matplotlib.use('Agg')import matplotlib.pyplot as pltimport base64import ioclass BaseCalendarMixin:    """カレンダー関連Mixinの、基底クラス"""    first_weekday = 0  # 0は月曜から、1は火曜から。6なら日曜日からになります。お望みなら、継承したビューで指定してください。    week_names = ['月', '火', '水', '木', '金', '土', '日']  # これは、月曜日から書くことを想定します。['Mon', 'Tue'...    def setup_calendar(self):        """内部カレンダーの設定処理        calendar.Calendarクラスの機能を利用するため、インスタンス化します。        Calendarクラスのmonthdatescalendarメソッドを利用していますが、デフォルトが月曜日からで、        火曜日から表示したい(first_weekday=1)、といったケースに対応するためのセットアップ処理です。        """        self._calendar = calendar.Calendar(self.first_weekday)    def get_week_names(self):        """first_weekday(最初に表示される曜日)にあわせて、week_namesをシフトする"""        week_names = deque(self.week_names)        week_names.rotate(-self.first_weekday)  # リスト内の要素を右に1つずつ移動...なんてときは、dequeを使うと中々面白いです        return week_names class MonthCalendarMixin(BaseCalendarMixin):    """月間カレンダーの機能を提供するMixin"""    def get_previous_month(self, date):        """前月を返す"""        if date.month == 1:            return  date.replace(year=date.year-1, month=12, day=1)        else:            return  date.replace(month=date.month-1, day=1)    def get_next_month(self, date):        """次月を返す"""        if date.month == 12:           return  date.replace(year=date.year+1, month=1, day=1)        else:           return  date.replace(month=date.month+1, day=1)            def get_month_days(self, date):        """その月の全ての日を返す"""        return self._calendar.monthdatescalendar(date.year, date.month)        def get_current_month(self):        """pk"""        month = self.kwargs.get('month')        year = self.kwargs.get('year')                if month and year:            month = datetime.date(year=int(year), month=int(month), day=1)                    else:            month = datetime.date.today().replace(day=1)                    return month        def get_select_day(self):        month = self.kwargs.get('month')        year = self.kwargs.get('year')        day = self.kwargs.get('day')        if month and year and day:            month = datetime.date(year=int(year), month=int(month), day=int(day))         else:            month = datetime.date.today()        return month    def get_month_calendar(self):        """月間カレンダー情報の入った辞書を返す"""        self.setup_calendar()        current_month = self.get_current_month()        calendar_data = {            'now': datetime.date.today(),            'month_days': self.get_month_days(current_month),            'month_current': current_month,            'month_previous': self.get_previous_month(current_month),            'month_next': self.get_next_month(current_month),            'week_names': self.get_week_names(),            'categorys': self.get_category(),            'select_day': self.get_select_day(),        }        return calendar_data   class MonthWithScheduleMixin(MonthCalendarMixin):    """スケジュール付きの、月間カレンダーを提供するMixin"""    def get_month_schedules(self, start, end, days, categorys):        """それぞれの日とスケジュールを返す"""        lookup = {            # '例えば、date__range: (1日, 31日)'を動的に作る            '{}__range'.format(self.date_field): (start, end)        }        # 例えば、Schedule.objects.filter(date__range=(1日, 31日)) になる        queryset = self.model.objects.filter(**lookup)                # {1日のdatetime: 1日のスケジュール全て, 2日のdatetime: 2日の全て...}のような辞書を作る        day_schedules = {day: [] for week in days for day in week}               for money in queryset:            money_date = getattr(money, self.date_field)            day_schedules[money_date].append(money)        # day_schedules辞書を、周毎に分割する。[{1日: 1日のスケジュール...}, {8日: 8日のスケジュール...}, ...]        # 7個ずつ取り出して分割しています。        size = len(day_schedules)        return [{key: day_schedules[key] for key in itertools.islice(day_schedules, i, i+7)} for i in range(0, size, 7)]    def get_month_calendar(self):        calendar_context = super().get_month_calendar()        month_days = calendar_context['month_days']        categorys = calendar_context['categorys']        month_first = month_days[0][0]        month_last = month_days[-1][-1]        calendar_context['month_day_schedules'] = self.get_month_schedules(            month_first,            month_last,            month_days,            categorys        )        return calendar_context        def get_previous_month_calendar(self):        calendar_context = super().get_month_calendar()        month_days = calendar_context['month_previous']        categorys = calendar_context['categorys']        month_first = month_days[0][0]        month_last = month_days[-1][-1]        calendar_context['month_day_schedules'] = self.get_month_schedules(            month_first,            month_last,            month_days,            categorys        )        return calendar_context        def get_week_calendar(self,**kwargs):        calendar_context = self.get_month_calendar()        year = kwargs.get('year')        month = kwargs.get('month')        day = kwargs.get('day')        for week_schedule in calendar_context['month_day_schedules']:            for year_week_day in week_schedule.keys():                if datetime.date(year=year,month=month,day=day) == year_week_day:                    calendar_context['week_schedules'] = week_schedule        return calendar_context        def get_graph(self):        context = self.get_week_calendar(**self.kwargs)        x = []        y = {}        for c in context['categorys']:            y[c] = []                for k,v in context['week_schedules'].items():                        x.append(str(k.month) + "/" + str(k.day))            for i,c in enumerate(context['categorys']):                                if v == []:                    y[c].append(0)                else:                    if i == 0:                        y[c].append(v[0].money_a)                    elif i == 1:                        y[c].append(v[0].money_b)                    elif i == 2:                        y[c].append(v[0].money_c)                    elif i == 3:                        y[c].append(v[0].money_d)                graph_context = {'graph':{}}                   for category,y in y.items():            graph_context['graph']['graph_' + category] = self.setPlt(x,y,category)        return graph_context            def setPlt(self,x,y,category):        plt.xlabel("Date")        plt.ylabel("yen")        plt.plot(x, y, color='red', marker='o', label=category)        plt.legend()        buf = io.BytesIO()        plt.savefig(buf, format='svg')        graph = base64.b64encode(buf.getvalue())        graph = graph.decode("utf-8")        plt.clf()        return graph                def get_category(self):        if Category == None:            category = ["未設定","未設定","未設定","未設定"]        else:            a = Category.objects.values_list('category_a', flat=True).get(id=1)            b = Category.objects.values_list('category_b', flat=True).get(id=1)            c = Category.objects.values_list('category_c', flat=True).get(id=1)            d = Category.objects.values_list('category_d', flat=True).get(id=1)            category = [a,b,c,d]        return category